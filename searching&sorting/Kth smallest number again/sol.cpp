/*
Kth smallest number again

Dexter was good in finding the K th smallest number from a set of numbers. 
He thought he could solve any problem related to K th smallest number. 
His friend Pipi challenged him with a problem.

He gave him various ranges of number, These numbers were arranged in 
increasing order(only distinct numbers to be taken into account). 
Now he asked him to find the K th smallest number in the sequence, again and again.

Input Format
The first line contains T, the number of test cases.
For each test case, there will be two integers N and Q.
Then N lines follow each line containing two integers A and B (denoting the range A-B)
Then Q lines follow each line containing a non-negative integer K .

Output Format
For each query output the K th smallest number.

Constraints
1 <= T <= 100
1 <= N <= 100
1 <= Q <= 1000
-10^18 <= A <= B <= 10^18
K >= 1

N.B. If Kth smallest number is not present in the series, print -1

Sample Input
1
1 3
1 5
1
3
6
Sample Output
1
3
-1
Time Limit: 5
Memory Limit: 256
Source Limit:
Explanation
The numbers are "1 2 3 4 5". The 1st smallest number is 1
The 3rd smallest number is 3 The 6th smallest number is not present. Hence answer is -1

*/

#include <bits/stdc++.h>
using namespace std;
int main(){
    int t;  cin>> t;
    while (t--){
        long long int n, q; cin >> n >> q;
        vector< pair < long long int, long long int > >v;
        for (long long int i=0; i< n; i++){
            long long int x,y; cin >> x >> y;
            v.push_back ({x,y});
        }
        sort (v.begin(), v.end()); 
        long long int idx=0;
        for (long long int i=1; i< v.size(); i++){
             if (v[idx].second >= v[i].first)v[idx].second= max (v[idx].second, v[i].second);
             else{
                idx++;
                v[idx]= v[i];
            }
        }
        while (q--){
            long long int k; cin >> k;
            long long int ans=-1;
            for (long long int i=0; i<= idx; i++){
                if ((v[i].second - v[i].first + 1) >= k){
                    ans= v[i].first + k -1;
                    break; 
                }     
                else k= k - (v[i].second - v[i].first + 1);
            }
            cout << ans << endl;
        }
    }
    return 0;
}